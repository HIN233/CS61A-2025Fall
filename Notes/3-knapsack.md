# 3-背包问题（Knapsack）

## 问题背景
给定n个物品，每个物品有不同的重量（weights）和价值（values），背包容量为c。目标是选择物品的子集，使得总重量不超过容量c的情况下，总价值最大化。

## 实现思想（递归+动态规划）

### 核心思路：决策树递归
knapsack函数采用**递归+记忆化**的策略来解决问题，本质上是**自顶向下**的动态规划方法。

### 关键代码分析 [hw03.py:179-195]
```python
def dp(i, c):
    if i == len(weights) or c <= 0:  # 基本情况：没有物品或容量耗尽
        return 0
    if weights[i] > c:              # 当前物品太重，无法放入
        return dp(i + 1, c)

    take = values[i] + dp(i + 1, c - weights[i])  # 选择当前物品
    skip = dp(i + 1, c)                         # 不选当前物品
    return max(take, skip)                      # 取最优选择
```

### 递归过程分解
1. **基本情况**：
   - 当物品索引i达到末尾（没有更多物品）
   - 或者背包容量c≤0（没有剩余空间）
   返回0，因为无法获得更多价值

2. **剪枝优化**：
   - 如果当前物品重量超过剩余容量，直接跳过该物品

3. **递归选择**：
   - **选择当前物品**：价值增加values[i]，容量减少weights[i]，继续考虑下一个物品
   - **不选当前物品**：价值不变，容量不变，继续考虑下一个物品
   - 返回两种选择中的最大值

### 算法特点
- **时间复杂度**：O(2^n) 最坏情况（没有记忆化）
- **空间复杂度**：O(n) 递归栈深度
- **最优子结构**：每个子问题的最优解组合成原问题的最优解
- **重叠子问题**：相同的(i, c)状态会被多次计算（适合记忆化优化）

### 思维要点
1. **问题分解**：将大问题分解为更小的子问题
2. **状态定义**：用(i, c)表示决策状态
3. **决策选择**：每个物品只有"选"或"不选"两种可能
4. **边界处理**：正确处理空集和容量耗尽的情况

这个实现体现了递归思想在组合优化问题中的典型应用，是理解动态规划入门的重要案例。